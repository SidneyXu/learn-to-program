


Creating DTO’s (POJO’s/POCO’s)
—
—
—
—
—

val p: String by Delegates.lazy {
// compute the string
}


Lazy property
Extension Functions
Creating a singleton
If not null shorthand

11
val files = File("Test").listFiles()
println(files?.size)
val files = File("Test").listFiles()
println(files?.size ?: "empty")

val data = ...
val email = data["email"] ?: throw IllegalStateException("Email is missing!")
val data = ...
data?.let {
... // execute this block if not null
}

fun transform(color: String): Int {
return when (color) {
"Red" -> 0
"Green" -> 1
"Blue" -> 2
else -> throw IllegalArgumentException("Invalid color param value")
}
}

fun test() {
val result = try {
count()
} catch (e: ArithmeticException) {
throw IllegalStateException(e)
}
// Working with result
}
If not null and else shorthand
Executing a statement if null
Execute if not null
Return on when statement
Return on try catch block
Return on if statement
12
fun foo(param: Int) {
val result = if (param == 1) {
"one"
} else if (param == 2) {
"two"
} else {
"three"
}
}
fun theAnswer() = 42
This is equivalent to
fun theAnswer(): Int {
return 42
}
This can be effectively combined with other idioms, leading to shorter code. E.g. with the when-expression:
fun transform(color: String): Int = when (color) {
"Red" -> 0
"Green" -> 1
"Blue" -> 2
else -> throw IllegalArgumentException("Invalid color param value")
}


----------------------------------



backing field of a property, use the $ prefix
avoid use _ or m_ or other notation
if a function return unit, the return type should be ommitted


--------------------------------------



This Expression
—
—
To denote the current receiver, we use this expressions:
In a member of a class, this refers to the current object of that class
In an extension function or an extension function literal, this denotes the receiver parameter that is passed on the lefthand
side of a dot.
If this has no qualifiers, it refers to the innermost enclosing scope. To refer to this in other scopes, label qualifiers are
used:

Qualified this
To access this from an outer scope (a class, or extension function, or labeled extension function literal we write
this@label where @label is a label on the scope this is meant to be from:
class A { // implicit label @A
inner class B { // implicit label @B
fun Int.foo() { // implicit label @foo
val a = this@A // A's this
val b = this@B // B's this
val c = this // foo()'s receiver, an Int
val c1 = this@foo // foo()'s receiver, an Int
val funLit = @lambda {String.() ->
val d = this // funLit's receiver
val d1 = this@lambda // funLit's receiver
}
val funLit2 = { (s: String) ->
// foo()'s receiver, since enclosing function literal
// doesn't have any receiver
val d1 = this
}
}
}
}





Null Safety
Nullable types and Non-Null Types
One of the most common pitfalls in many programming languages, including Java is that of accessing a member of a null
references, resulting in null reference exceptions. In Java this would be the equivalent of a NullPointerException or
NPE for short.
Kotlin’s type system is aimed to eliminate NullPointerException ’s from our code. The only possible causes of NPE’s
may be
An explicit call to throw NullPointerException()
External Java code has caused it
There’s some data inconsistency with regard to initialization (an uninitialized this available in a constructor is used
somewhere)
In Kotlin the type system distinguishes between references that can hold null (nullable references) and those that can not
(non-null references). For example, a regular variable of type String can not hold null:
var a: String = "abc"
a = null // compilation error
To allow nulls, we can declare a variable as nullable string, written String? :
var b: String? = "abc"
b = null // ok
Now, if you call a method on a , it’s guaranteed not to cause an NPE, so you can safely say
val l = a.length()
But if you want to call the same method on b , that would not be safe, and the compiler reports an error:
val l = b.length() // error: variable 'b' can be null
But we still need to call that method, right? There are a few ways of doing that.

Checking for null in conditions
First, you can explicitly check if b is null, and handle the two options separately:
val l = if (b != null) b.length() else -1
The compiler tracks the information about the check you performed, and allows the call to length() inside the if. More
complex conditions are supported as well:

if (b != null && b.length() > 0)
print("String of length ${b.length()}")
else
print("Empty string")
Note that this only works where b is immutable (i.e. a local variable which is not modified between the check and the usage
or a member valwhich has a backing field and is not overridable), because otherwise it might happen that b changes to
null after the check.


Safe Calls
Your second option is the safe call operator, written ?. :
b?.length()
This returns b.length() if b is not null, and null otherwise. The type of this expression is Int? .
Safe calls are useful in chains. For example, if Bob, an Employee, may be assigned to a Department (or not), that in turn
may have another Employee as a department head, then to obtain the name of Bob’s department head, if any), we write the
following:
bob?.department?.head?.name
Such a chain returns null if any of the properties in it is null.

Elvis Operator
When we have a nullable reference r , we can say “if r is not null, use it, otherwise use some non-null value x ”:
val l: Int = if (b != null) b.length() else -1
Along with the complete if-expression, this can be expressed with the Elvis operator, written ?: :
val l = b?.length() ?: -1
If the expression to the left of ?: is not null, the elvis operator returns it, otherwise it returns the expression to the right. Note
that the right-hand side expression is evaluated only if the left-hand side is null.
Note that, since throw and return are expressions in Kotlin, they can also be used on the right hand side of the elvis
operator. This can be very handy, for example, for checking function arguments:
fun foo(node: Node): String? {
val parent = node.getParent() ?: return null
val name = node.getName() ?: throw IllegalArgumentException("name expected")
// ...
}


The !! Operator
The third option is for NPE-lovers. We can write b!! , and this will return a non-null value of b (e.g., a String in our
example) or throw an NPE if b is null:
val l = b!!.length()
Thus, if you want an NPE, you can have it, but you have to ask for it explicitly, and it does not appear out of the blue.
By the way, !! is added for conciseness, and formerly was emulated by an extension function from the standard library,
defined as follows:
inline fun <T : Any> T?.sure(): T =
if (this == null)
throw NullPointerException()
else
this

Safe Casts
Regular casts may result into a ClassCastException if the object is not of the target type. Another option is to use safe
casts that return null if the attempt was not successful:
val aInt: Int? = a as? Int


Annotation Declaration

Reflection

Builder


Function
//  Infix notation
//Functions can also be called using infix notations when
//They are member functions or extension functions
//They have a single parameter
// Define extension to Int
fun Int.shl(x: Int): Int {
    return x * 10
}
//// call extension function using infix notation
//1 shl 2
//// is the same as
//1.shl(2)







