package

package my.demo
import java.util.*




nullable
Return null if str does not hold an integer:
fun parseInt(str: String): Int? {
// ...
}


Use a function returning nullable value:
fun main(args: Array<String>) {
if (args.size() < 2) {
print("Two integers expected")
return
}
val x = parseInt(args[0])
val y = parseInt(args[1])
// Using `x * y` yields error because they may hold nulls.
if (x != null && y != null) {
// x and y are automatically cast to non-nullable after null check
print(x * y)
}
}
or
// ...
if (x == null) {
print("Wrong number format in '${args[0]}'")
return
}
if (y == null) {
print("Wrong number format in '${args[1]}'")
return
}
// x and y are automatically cast to non-nullable after null check
print(x * y)



Using type checks and automatic casts
The is operator checks if an expression is an instance of a type. If an immutable local variable or property is checked for a
specific type, there’s no need to cast it explicitly:
Using type checks and automatic casts
6
fun getStringLength(obj: Any): Int? {
if (obj is String) {
// `obj` is automatically cast to `String` in this branch
return obj.length
}
// `obj` is still of type `Any` outside of the type-checked branch
return null
}
or
fun getStringLength(obj: Any): Int? {
if (obj !is String)
return null
// `obj` is automatically cast to `String` in this branch
return obj.length
}
or even
fun getStringLength(obj: Any): Int? {
// `obj` is automatically cast to `String` on the right-hand side of `&&`
if (obj is String && obj.length > 0)
return obj.length
return null
}





when
fun cases(obj: Any) {
when (obj) {
1 -> print("One")
"Hello" -> print("Greeting")
is Long -> print("Long")
!is String -> print("Not a string")
else -> print("Unknown")
}
}




collection
Using function literals to filter and map collections:
names filter { it.startsWith("A") } sortBy { it } map { it.toUpperCase() } forEach {
print(it) }


Idioms
A collection of random and frequently used idioms in Kotlin.
If you have a favorite idiom, contribute it. Do a pull request.
data class Customer(val name: String, val email: String)
provides a Customer class with the following functionality:
getters (and setters in case of var’s) for all properties
equals()
hashCode()
toString()
copy()
component1() , component2() , …, for all properties (see Data classes)
val a = foo()
fun foo(a: Int = 0, b: String = "") { ... }
val positives = list.filter { x -> x > 0 }
Or alternatively, even shorter:
val positives = list.filter { it > 0 }
println("Name $name")
when (x) {
is Foo -> ...
is Bar -> ...
else -> ...
}
Idioms
Creating DTO’s (POJO’s/POCO’s)
—
—
—
—
—
—
Declaring a final local variable
Default values for function parameters
Filtering a list
String Interpolation
Instance Checks
Traversing a map/list of pairs
10
for ((k, v) in map) {
println("$k -> $v")
}
k , v can be called anything.
for (i in 1..100) { ... }
for (x in 2..10) { ... }
val list = listOf("a", "b", "c")
val map = mapOf("a" to 1, "b" to 2, "c" to 3)
println(map["key"])
map["key"] = value
val p: String by Delegates.lazy {
// compute the string
}
fun String.spaceToCamelCase() { ... }
"Convert this to camelcase".spaceToCamelCase()
object Resource {
val name = "Name"
}
Using ranges
Read-only list
Read-only map
Accessing a map
Lazy property
Extension Functions
Creating a singleton
If not null shorthand
11
val files = File("Test").listFiles()
println(files?.size)
val files = File("Test").listFiles()
println(files?.size ?: "empty")
val data = ...
val email = data["email"] ?: throw IllegalStateException("Email is missing!")
val data = ...
data?.let {
... // execute this block if not null
}
fun transform(color: String): Int {
return when (color) {
"Red" -> 0
"Green" -> 1
"Blue" -> 2
else -> throw IllegalArgumentException("Invalid color param value")
}
}
fun test() {
val result = try {
count()
} catch (e: ArithmeticException) {
throw IllegalStateException(e)
}
// Working with result
}
If not null and else shorthand
Executing a statement if null
Execute if not null
Return on when statement
Return on try catch block
Return on if statement
12
fun foo(param: Int) {
val result = if (param == 1) {
"one"
} else if (param == 2) {
"two"
} else {
"three"
}
}
fun theAnswer() = 42
This is equivalent to
fun theAnswer(): Int {
return 42
}
This can be effectively combined with other idioms, leading to shorter code. E.g. with the when-expression:
fun transform(color: String): Int = when (color) {
"Red" -> 0
"Green" -> 1
"Blue" -> 2
else -> throw IllegalArgumentException("Invalid color param value")
}


<<<<<<< HEAD
default and named params
fun bar(i: Int, s: String = "", b: Boolean = true) {}

fun usage() {
    bar(1, b = false)
}
=======
----------------------------------


Coding Conventions
>>>>>>> 4d34b0efa935a6c10cfbbb315bd7e6f9767993e4

backing field of a property, use the $ prefix
avoid use _ or m_ or other notation
if a function return unit, the return type should be ommitted


--------------------------------------


classes and object



28






