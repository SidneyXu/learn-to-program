


Creating DTO’s (POJO’s/POCO’s)
—
—
—
—
—


Traversing a map/list of pairs
10
for ((k, v) in map) {
println("$k -> $v")
}
k , v can be called anything.
for (i in 1..100) { ... }
for (x in 2..10) { ... }
val list = listOf("a", "b", "c")
val map = mapOf("a" to 1, "b" to 2, "c" to 3)
println(map["key"])
map["key"] = value
val p: String by Delegates.lazy {
// compute the string
}
fun String.spaceToCamelCase() { ... }
"Convert this to camelcase".spaceToCamelCase()
object Resource {
val name = "Name"
}


Using ranges
Read-only list
Read-only map
Accessing a map
Lazy property
Extension Functions
Creating a singleton
If not null shorthand
11
val files = File("Test").listFiles()
println(files?.size)
val files = File("Test").listFiles()
println(files?.size ?: "empty")
val data = ...
val email = data["email"] ?: throw IllegalStateException("Email is missing!")
val data = ...
data?.let {
... // execute this block if not null
}
fun transform(color: String): Int {
return when (color) {
"Red" -> 0
"Green" -> 1
"Blue" -> 2
else -> throw IllegalArgumentException("Invalid color param value")
}
}
fun test() {
val result = try {
count()
} catch (e: ArithmeticException) {
throw IllegalStateException(e)
}
// Working with result
}
If not null and else shorthand
Executing a statement if null
Execute if not null
Return on when statement
Return on try catch block
Return on if statement
12
fun foo(param: Int) {
val result = if (param == 1) {
"one"
} else if (param == 2) {
"two"
} else {
"three"
}
}
fun theAnswer() = 42
This is equivalent to
fun theAnswer(): Int {
return 42
}
This can be effectively combined with other idioms, leading to shorter code. E.g. with the when-expression:
fun transform(color: String): Int = when (color) {
"Red" -> 0
"Green" -> 1
"Blue" -> 2
else -> throw IllegalArgumentException("Invalid color param value")
}


----------------------------------



backing field of a property, use the $ prefix
avoid use _ or m_ or other notation
if a function return unit, the return type should be ommitted


--------------------------------------



Extensions
Extension function
fun MutableList<Int>.swap(x: Int, y: Int) {
    val tmp = this[x] // 'this' corresponds to the list
    this[x] = this[y]
    this[y] = tmp
}
The this keyword inside an extension function corresponds to the receiver object (the one that is passed before the dot).
Now, we can call such a function on any MutableList<Int> :
val l = mutableListOf(1, 2, 3)
l.swap(0, 2) // 'this' inside 'swap()' will hold the value of 'l'
Of course, this function makes sense for any MutableList<T> , and we can make it generic:
fun <T> MutableList<T>.swap(x: Int, y: Int) {
val tmp = this[x] // 'this' corresponds to the list
this[x] = this[y]
this[y] = tmp
}
We declare the generic type parameter before the function name for it to be available in the receiver type expression. See
Generic functions.
Extensions do not actually modify classes they extend. By defining an extension, you do not insert new members into a class,
but merely make new functions callable with the dot-notation on instances of this class.
We would like to emphasize that extension functions are dispatched statically, i.e. they are not virtual by receiver type. If
there’s a member and extension of the same type both applicable to given arguments, a member always wins. For
example:
class C {
fun foo() { println("member") }
}
fun C.foo() { println("extension") }
If we call c.foo() of any c of type C , it will print “member”, not “extension”.


Nullable Receiver
Note that extensions can be defined with a nullable receiver type. Such extensions can be called on an object variable even
if its value is null, and can check for this == null inside the body. This is what allows you to call toString() in Kotlin
without checking for null: the check happens inside the extension function.
fun Any?.toString(): String {
if (this == null) return "null"
// after the null check, 'this' is autocast to a non-null type, so the toString()
below
// resolves to the member function of the Any class
return toString()
}
Similarly to functions, Kotlin supports extension properties:
val <T> List<T>.lastIndex: Int
get() = size - 1
Note that, since extensions do not actually insert members into classes, there’s no efficient way for an extension property to
have a backing field. This is why initializers are not allowed for extension properties. Their behavior can only be defined
by explicitly providing getters/setters.
Example:
val Foo.bar = 1 // error: initializers are not allowed for extension properties
If a class has a companion object defined, you can also define extension functions and properties for the companion object:
class MyClass {
companion object { } // will be called "Companion"
}
fun MyClass.Companion.foo() {
// ...
}
Just like regular members of the companion object, they can be called using only the class name as the qualifier:
MyClass.foo()
Most of the time we define extensions on the top level, i.e. directly under packages:
package foo.bar
fun Baz.goo() { ... }


Multi-Declarations
val (name, age) = person
val name = person.component1()
for ((a, b) in collection) { ... }
for ((key, value) in map)


Ranges
if (str in "island".."isle") println(str)
for (i in 4 downTo 1) print(i)
for (i in 1..4 step 2) print(i) /
for (i in 4 downTo 1 step 2) print(i)
for (i in (1..4).reversed()) print(i) /


Type Checks and Casts
is and !is Operators
if (obj is String) {
print(obj.length)
}
if (obj !is String) { // same as !(obj is String)
print("Not a String")
}
else {
}

Smart Casts
In many cases, one does not need to use explicit cast operators in Kotlin, because the compiler tracks the is -checks for
immutable values and inserts (safe) casts automatically when needed:
fun demo(x: Any) {
if (x is String) {
print(x.length) // x is automatically cast to String
}
}
The compiler is smart enough to know a cast to be safe if a negative check leads to a return:
if (x !is String) return
print(x.length) // x is automatically cast to String


Such smart casts work for when-expressions and while-loops as well:
when (x) {
is Int -> print(x + 1)
is String -> print(x.length + 1)
is Array<Int> -> print(x.sum())
}


“Unsafe” cast operator
Usually, the cast operator throws an exception if the cast is not possible. Thus, we call it unsafe. The unsafe cast in Kotlin is
done by the infix operator as (see operator precedence):
val x: String = y as String
Note that null cannot be cast to String as this type is not nullable, i.e. if y is null, the code above throws an exception.
In order to match Java cast semantics we have to have nullable type at cast right hand side, like
val x: String? = y as String?
To avoid an exception being thrown, one can use a safe cast operator as? that returns null on failure:
val x: String? = y as? String
Note that despite the fact that the right-hand side of as? is a non-null type String the result of the cast is nullable.



This Expression
—
—
To denote the current receiver, we use this expressions:
In a member of a class, this refers to the current object of that class
In an extension function or an extension function literal, this denotes the receiver parameter that is passed on the lefthand
side of a dot.
If this has no qualifiers, it refers to the innermost enclosing scope. To refer to this in other scopes, label qualifiers are
used:

Qualified this
To access this from an outer scope (a class, or extension function, or labeled extension function literal we write
this@label where @label is a label on the scope this is meant to be from:
class A { // implicit label @A
inner class B { // implicit label @B
fun Int.foo() { // implicit label @foo
val a = this@A // A's this
val b = this@B // B's this
val c = this // foo()'s receiver, an Int
val c1 = this@foo // foo()'s receiver, an Int
val funLit = @lambda {String.() ->
val d = this // funLit's receiver
val d1 = this@lambda // funLit's receiver
}
val funLit2 = { (s: String) ->
// foo()'s receiver, since enclosing function literal
// doesn't have any receiver
val d1 = this
}
}
}
}



Equality
In Kotlin there are two types of equality:
Referential equality (two references point to the same object)
Structural equality (a check for equals() )

Referential equality
Referential equality is checked by the === operation (and its negated counterpart !== ). a === b evaluates to true if
and only if a and b point to the same object.
Alternatively, you can check for reference equality using a built-in inline function identityEquals() that can be called in
the following way
a.identityEquals(b)
// or
a identityEquals b // infix call
This also returns true if and only if a and b point to the same object.

Structural equality
Structural equality is checked by the == operation (and its negated counterpart != ). By convention, an expression like a
== b is translated to
a?.equals(b) ?: b === null
I.e. if a is not null , it calls the equals(Any?) function, otherwise (i.e. a is null ) it checks that b is referentially
equal to null .
Note that there’s no point in optimizing your code when comparing to null explicitly: a == null will be automatically
translated to a === null .



Null Safety
Nullable types and Non-Null Types
One of the most common pitfalls in many programming languages, including Java is that of accessing a member of a null
references, resulting in null reference exceptions. In Java this would be the equivalent of a NullPointerException or
NPE for short.
Kotlin’s type system is aimed to eliminate NullPointerException ’s from our code. The only possible causes of NPE’s
may be
An explicit call to throw NullPointerException()
External Java code has caused it
There’s some data inconsistency with regard to initialization (an uninitialized this available in a constructor is used
somewhere)
In Kotlin the type system distinguishes between references that can hold null (nullable references) and those that can not
(non-null references). For example, a regular variable of type String can not hold null:
var a: String = "abc"
a = null // compilation error
To allow nulls, we can declare a variable as nullable string, written String? :
var b: String? = "abc"
b = null // ok
Now, if you call a method on a , it’s guaranteed not to cause an NPE, so you can safely say
val l = a.length()
But if you want to call the same method on b , that would not be safe, and the compiler reports an error:
val l = b.length() // error: variable 'b' can be null
But we still need to call that method, right? There are a few ways of doing that.

Checking for null in conditions
First, you can explicitly check if b is null, and handle the two options separately:
val l = if (b != null) b.length() else -1
The compiler tracks the information about the check you performed, and allows the call to length() inside the if. More
complex conditions are supported as well:

if (b != null && b.length() > 0)
print("String of length ${b.length()}")
else
print("Empty string")
Note that this only works where b is immutable (i.e. a local variable which is not modified between the check and the usage
or a member valwhich has a backing field and is not overridable), because otherwise it might happen that b changes to
null after the check.


Safe Calls
Your second option is the safe call operator, written ?. :
b?.length()
This returns b.length() if b is not null, and null otherwise. The type of this expression is Int? .
Safe calls are useful in chains. For example, if Bob, an Employee, may be assigned to a Department (or not), that in turn
may have another Employee as a department head, then to obtain the name of Bob’s department head, if any), we write the
following:
bob?.department?.head?.name
Such a chain returns null if any of the properties in it is null.

Elvis Operator
When we have a nullable reference r , we can say “if r is not null, use it, otherwise use some non-null value x ”:
val l: Int = if (b != null) b.length() else -1
Along with the complete if-expression, this can be expressed with the Elvis operator, written ?: :
val l = b?.length() ?: -1
If the expression to the left of ?: is not null, the elvis operator returns it, otherwise it returns the expression to the right. Note
that the right-hand side expression is evaluated only if the left-hand side is null.
Note that, since throw and return are expressions in Kotlin, they can also be used on the right hand side of the elvis
operator. This can be very handy, for example, for checking function arguments:
fun foo(node: Node): String? {
val parent = node.getParent() ?: return null
val name = node.getName() ?: throw IllegalArgumentException("name expected")
// ...
}


The !! Operator
The third option is for NPE-lovers. We can write b!! , and this will return a non-null value of b (e.g., a String in our
example) or throw an NPE if b is null:
val l = b!!.length()
Thus, if you want an NPE, you can have it, but you have to ask for it explicitly, and it does not appear out of the blue.
By the way, !! is added for conciseness, and formerly was emulated by an extension function from the standard library,
defined as follows:
inline fun <T : Any> T?.sure(): T =
if (this == null)
throw NullPointerException()
else
this

Safe Casts
Regular casts may result into a ClassCastException if the object is not of the target type. Another option is to use safe
casts that return null if the attempt was not successful:
val aInt: Int? = a as? Int


Annotation Declaration

Reflection



94






