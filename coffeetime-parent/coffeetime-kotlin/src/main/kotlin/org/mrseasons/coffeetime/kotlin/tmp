


nullable
Return null if str does not hold an integer:
fun parseInt(str: String): Int? {
// ...
}


Use a function returning nullable value:
fun main(args: Array<String>) {
if (args.size() < 2) {
print("Two integers expected")
return
}
val x = parseInt(args[0])
val y = parseInt(args[1])
// Using `x * y` yields error because they may hold nulls.
if (x != null && y != null) {
// x and y are automatically cast to non-nullable after null check
print(x * y)
}
}
or
// ...
if (x == null) {
print("Wrong number format in '${args[0]}'")
return
}
if (y == null) {
print("Wrong number format in '${args[1]}'")
return
}
// x and y are automatically cast to non-nullable after null check
print(x * y)



Using type checks and automatic casts
The is operator checks if an expression is an instance of a type. If an immutable local variable or property is checked for a
specific type, there’s no need to cast it explicitly:
Using type checks and automatic casts
6
fun getStringLength(obj: Any): Int? {
if (obj is String) {
// `obj` is automatically cast to `String` in this branch
return obj.length
}
// `obj` is still of type `Any` outside of the type-checked branch
return null
}
or
fun getStringLength(obj: Any): Int? {
if (obj !is String)
return null
// `obj` is automatically cast to `String` in this branch
return obj.length
}
or even
fun getStringLength(obj: Any): Int? {
// `obj` is automatically cast to `String` on the right-hand side of `&&`
if (obj is String && obj.length > 0)
return obj.length
return null
}








collection
Using function literals to filter and map collections:
names filter { it.startsWith("A") } sortBy { it } map { it.toUpperCase() } forEach {
print(it) }


Idioms
A collection of random and frequently used idioms in Kotlin.
If you have a favorite idiom, contribute it. Do a pull request.
data class Customer(val name: String, val email: String)
provides a Customer class with the following functionality:
getters (and setters in case of var’s) for all properties
equals()
hashCode()
toString()
copy()
component1() , component2() , …, for all properties (see Data classes)
val a = foo()
fun foo(a: Int = 0, b: String = "") { ... }
val positives = list.filter { x -> x > 0 }
Or alternatively, even shorter:
val positives = list.filter { it > 0 }
println("Name $name")
when (x) {
is Foo -> ...
is Bar -> ...
else -> ...
}
Idioms
Creating DTO’s (POJO’s/POCO’s)
—
—
—
—
—
—
Declaring a final local variable
Default values for function parameters
Filtering a list
String Interpolation
Instance Checks
Traversing a map/list of pairs
10
for ((k, v) in map) {
println("$k -> $v")
}
k , v can be called anything.
for (i in 1..100) { ... }
for (x in 2..10) { ... }
val list = listOf("a", "b", "c")
val map = mapOf("a" to 1, "b" to 2, "c" to 3)
println(map["key"])
map["key"] = value
val p: String by Delegates.lazy {
// compute the string
}
fun String.spaceToCamelCase() { ... }
"Convert this to camelcase".spaceToCamelCase()
object Resource {
val name = "Name"
}
Using ranges
Read-only list
Read-only map
Accessing a map
Lazy property
Extension Functions
Creating a singleton
If not null shorthand
11
val files = File("Test").listFiles()
println(files?.size)
val files = File("Test").listFiles()
println(files?.size ?: "empty")
val data = ...
val email = data["email"] ?: throw IllegalStateException("Email is missing!")
val data = ...
data?.let {
... // execute this block if not null
}
fun transform(color: String): Int {
return when (color) {
"Red" -> 0
"Green" -> 1
"Blue" -> 2
else -> throw IllegalArgumentException("Invalid color param value")
}
}
fun test() {
val result = try {
count()
} catch (e: ArithmeticException) {
throw IllegalStateException(e)
}
// Working with result
}
If not null and else shorthand
Executing a statement if null
Execute if not null
Return on when statement
Return on try catch block
Return on if statement
12
fun foo(param: Int) {
val result = if (param == 1) {
"one"
} else if (param == 2) {
"two"
} else {
"three"
}
}
fun theAnswer() = 42
This is equivalent to
fun theAnswer(): Int {
return 42
}
This can be effectively combined with other idioms, leading to shorter code. E.g. with the when-expression:
fun transform(color: String): Int = when (color) {
"Red" -> 0
"Green" -> 1
"Blue" -> 2
else -> throw IllegalArgumentException("Invalid color param value")
}


<<<<<<< HEAD
default and named params
fun bar(i: Int, s: String = "", b: Boolean = true) {}

fun usage() {
    bar(1, b = false)
}
=======
----------------------------------


Coding Conventions
>>>>>>> 4d34b0efa935a6c10cfbbb315bd7e6f9767993e4

backing field of a property, use the $ prefix
avoid use _ or m_ or other notation
if a function return unit, the return type should be ommitted


--------------------------------------


classes and object


Visiblity
private — visible only in the declaring scope and its subscopes (inside the same module);
protected — (applicable only to class/interface members) like private , but also visible in subclasses;
internal — (used by default) visible everywhere within the same module (if the owner of declaring scope is visible);
public — visible everywhere (if the owner of declaring scope is visible).


Extensions
Extension function
fun MutableList<Int>.swap(x: Int, y: Int) {
    val tmp = this[x] // 'this' corresponds to the list
    this[x] = this[y]
    this[y] = tmp
}
The this keyword inside an extension function corresponds to the receiver object (the one that is passed before the dot).
Now, we can call such a function on any MutableList<Int> :
val l = mutableListOf(1, 2, 3)
l.swap(0, 2) // 'this' inside 'swap()' will hold the value of 'l'
Of course, this function makes sense for any MutableList<T> , and we can make it generic:
fun <T> MutableList<T>.swap(x: Int, y: Int) {
val tmp = this[x] // 'this' corresponds to the list
this[x] = this[y]
this[y] = tmp
}
We declare the generic type parameter before the function name for it to be available in the receiver type expression. See
Generic functions.
Extensions do not actually modify classes they extend. By defining an extension, you do not insert new members into a class,
but merely make new functions callable with the dot-notation on instances of this class.
We would like to emphasize that extension functions are dispatched statically, i.e. they are not virtual by receiver type. If
there’s a member and extension of the same type both applicable to given arguments, a member always wins. For
example:
class C {
fun foo() { println("member") }
}
fun C.foo() { println("extension") }
If we call c.foo() of any c of type C , it will print “member”, not “extension”.


Nullable Receiver
Note that extensions can be defined with a nullable receiver type. Such extensions can be called on an object variable even
if its value is null, and can check for this == null inside the body. This is what allows you to call toString() in Kotlin
without checking for null: the check happens inside the extension function.
fun Any?.toString(): String {
if (this == null) return "null"
// after the null check, 'this' is autocast to a non-null type, so the toString()
below
// resolves to the member function of the Any class
return toString()
}
Similarly to functions, Kotlin supports extension properties:
val <T> List<T>.lastIndex: Int
get() = size - 1
Note that, since extensions do not actually insert members into classes, there’s no efficient way for an extension property to
have a backing field. This is why initializers are not allowed for extension properties. Their behavior can only be defined
by explicitly providing getters/setters.
Example:
val Foo.bar = 1 // error: initializers are not allowed for extension properties
If a class has a companion object defined, you can also define extension functions and properties for the companion object:
class MyClass {
companion object { } // will be called "Companion"
}
fun MyClass.Companion.foo() {
// ...
}
Just like regular members of the companion object, they can be called using only the class name as the qualifier:
MyClass.foo()
Most of the time we define extensions on the top level, i.e. directly under packages:
package foo.bar
fun Baz.goo() { ... }








62






